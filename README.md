# LanguageModelTraining

# First 5 lines of the generated shakespeare.char samples:
ANGELO:
And come, my lord,
Who shall be your hands to my country's prayers?

DUKE VINCENTIO:
Now, enown to your noble majesty

# Model Architecture Exploration Results: (max_iters set at 3000)
layers = [2, 3, 5, 7]
losses = [1.3373, 1.2441, 1.1419, 1.0497]

Lowest validation loss: 1.0497
Model configuration: 7 layers, 5 heads  
Training done on Google Colab Tesla T4 with float16 precision.

# Dataset Token Report
Length of dataset in characters: 106,762  
Vocabulary size: 97  
Number of training tokens: 96,085  
Number of validation tokens: 10,677  

/content/nanoGPT/config/train_shakespeare_char.py

# Code Generation Samples: (First 20 lines)
json_loct(key, val);
					return NUL;
	}


	}


bol json_din_dict(struct JsonValue *dict, const char **dst_p, char *va_p, char *key, str c_p, char *)
{
	struct MBuct JsonValue *jv;
	if (!val)
		if (!== valal;
	return = 0;

	turn trrStralse(ctate = 0x->papate(ce, JstonVainte *valinte)
		if = (!== 0xES_A%)
	}
			->urete;
}
}

# Favorite generated snippet(s) that look the most coherent or interesting:

- Snippet 1: 
bol json_din_dict(struct JsonValue *dict, const char **dst_p, char *va_p, char *key, str c_p, char *)
{
struct MBuct JsonValue *jv;
if (!val)
if (!== valal;
return = 0;

turn trrStralse(ctate = 0x->papate(ce, JstonVainte *valinte)
if = (!== 0xES_A%)
}
->urete;
}
## Snippet 1 appears to be attempting to define a function for handling JSON dictionaries. Despite some syntax errors, it shows an effort to manage JSON values and keys.

- Snippet 2:
bool json_list_dict_pppt_dict_ew_fl(struct JsonValue *list, st char *dstonst conValue ***key, char const char ***dst_p)
if (st_pt Jstyp, JsonVainValie *****vay, | ize_t_ty, indinext, Jst_t_vaindint, **vaizex, izent, iole_t,
{
thint
vaint.valuene *cthasthas_p)
vas_pt = = vasxt_s_poooloptat;
statruct JsonValue **jvaist;
if d_geict_ding(lict, ct_p), stULin(st, JSO
## Snippet 2 seems to be defining a function for handling lists of JSON dictionaries. It includes some variable declarations and attempts to process JSON values.

- Snippet 3:
static bol json_loolu_float(struct JsonValue *dict, const const char ***dstx, char const char ****g,
{
unst JsonContewaintext;
char *char *c;
src = NUL;
if (list->cu.ct re {
if (ke >thaured;
retur_false(ct >patx, Jsene_past, *kendstx, JstyponVaintypaline);
}
if (lst->pat->c->p ke_FLIN_e(in;
*et = = ipt_chastypind(ct, JSOLICON_L;
if et->urr->u.v_ke;
}
}
return e;
}
## Snippet 3 seems to be defining a function for handling floating-point values in JSON dictionaries. It includes some error handling and attempts to process JSON values.

